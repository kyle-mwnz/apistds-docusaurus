"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3453],{4137:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(t),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||o;return t?a.createElement(m,s(s({ref:n},p),{},{components:t})):a.createElement(m,s({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=h;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[d]="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},9582:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=t(7462),i=(t(7294),t(4137));const o={},s=void 0,r={unversionedId:"api-design-development/APIDesign",id:"version-1.4.0/api-design-development/APIDesign",title:"APIDesign",description:"API Design",source:"@site/versioned_docs/version-1.4.0/api-design-development/2-APIDesign.md",sourceDirName:"api-design-development",slug:"/api-design-development/APIDesign",permalink:"/apistds-docusaurus/docs/api-design-development/APIDesign",draft:!1,tags:[],version:"1.4.0",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"APIArtefacts",permalink:"/apistds-docusaurus/docs/api-design-development/APIArtefacts"},next:{title:"Architecturaland Deployment Patterns",permalink:"/apistds-docusaurus/docs/api-design-development/Architecturaland Deployment Patterns"}},l={},c=[{value:"API Design",id:"api-design",level:2},{value:"When is an API appropriate?",id:"when-is-an-api-appropriate",level:3},{value:"Types of API",id:"types-of-api",level:3},{value:"API Design Principles",id:"api-design-principles",level:3},{value:"Future-Focused Design\xa0",id:"future-focused-design",level:4},{value:"Layering",id:"layering",level:4},{value:"Security",id:"security",level:5},{value:"Caching",id:"caching",level:5},{value:"Representation",id:"representation",level:5},{value:"Standards-Based",id:"standards-based",level:4},{value:"Designing an API",id:"designing-an-api",level:3},{value:"Design Considerations",id:"design-considerations",level:3},{value:"Design Driven Development",id:"design-driven-development",level:3},{value:"Interface Specification First",id:"interface-specification-first",level:4},{value:"Iterative Approach",id:"iterative-approach",level:4},{value:"Automation First",id:"automation-first",level:4},{value:"Granularity",id:"granularity",level:3},{value:"Interface Specification",id:"interface-specification",level:3},{value:"Orchestration",id:"orchestration",level:3},{value:"Software Development Kits (SDK)",id:"software-development-kits-sdk",level:3}],p={toc:c},d="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"api-design"},"API Design"),(0,i.kt)("p",null,"Application developers will invest heavily in using your API. They will\ninvest in learning the design and behaviour of your API, in developing\nand testing around your API and may even invest in developing an entire\nbusiness model on your API."),(0,i.kt)("p",null,"Good API designs will attract more developers. Conversely, bad API\ndesigns will drive away developers and drive up costs -- support costs,\nmaintenance costs and operating costs."),(0,i.kt)("h3",{id:"when-is-an-api-appropriate"},"When is an API appropriate?"),(0,i.kt)("p",null,"In the past, the default reaction to a requirement for capability has\nbeen to develop a web application. This is now gravitating towards APIs\nas the default. So, when is it better to build an API than a web\napplication? Below are some situations where an API may be more\nappropriate:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When commercial organisations or NGOs are screen scraping data from\nthe agency's website")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When the agency holds a single authoritative source of the truth")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Where there is a need for (near real time) information exchange with\na partner agency")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When parts of a business process are (or may be) outsourced")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When the agency's service can be included as part of a larger\nbusiness process")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When an agency needs internal systems to interact with cloud-based\nCOTS solutions (SaaS)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Where businesses require easy access to (public) information")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Where commercial organisations want to build capability into their\nown applications which will benefit the public (mobile/web apps)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When an agency expects other parties to act as agents or\nintermediaries for their services")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When an agency expects to support service delivery across multiple\nchannels"))),(0,i.kt)("h3",{id:"types-of-api"},"Types of API"),(0,i.kt)("p",null,"There are several different types of API and the type you choose may\ndepend on the technical use cases that you apply to both consumption and\nprovision of your API."),(0,i.kt)("p",null,'+------------+---------------------------------+----------------------+\n| API Type   | Description                     | Usage                |\n+============+=================================+======================+\n| REST       | Representational State Transfer | Creating distributed |\n|            | (REST) is the most common and   | system where a set   |\n|            | well understood API type. REST  | of API resources are |\n|            | should be considered an         | well defined. If     |\n|            | architectural style for         | medium latency       |\n|            | developing distributed          | resource creation or |\n|            | hypermedia systems. There is a  | modification (POST,  |\n|            | wealth of information and       | PUT, DELETE) is      |\n|            | tooling to support the          | required then        |\n|            | definition and creation of REST | typically a REST API |\n|            | APIs. Typically, a REST API     | is a better fit.     |\n|            | will have a well-defined and    | Typically used for   |\n|            | strongly typed schema           | synchronous          |\n|            | definition (OpenAPI) where      | interactions.        |\n|            | strict compliance can be        |                      |\n|            | achieved.                       |                      |\n+------------+---------------------------------+----------------------+\n| GraphQL    | GraphQL is an open source query | An API that has a    |\n|            | and manipulation language       | widely distributed   |\n|            | developed by Facebook primarily | client set with a    |\n|            | designed to empower API         | variety of data      |\n|            | consumers to consume only the   | requirements.        |\n|            | data that they require. A       | Particularly well    |\n|            | common criticism of REST is     | suited to high read  |\n|            | that only the entire resource   | (GET) clients        |\n|            | is available for consumption,   |                      |\n|            | sometimes referred to as "over  |                      |\n|            | fetching", however with GraphQL |                      |\n|            | the client decides the data     |                      |\n|            | that it requires. GraphQL also  |                      |\n|            | has a strongly typed schema     |                      |\n|            | (GraphQL Schema Definition      |                      |\n|            | Language -- SDL).               |                      |\n+------------+---------------------------------+----------------------+\n| As         | AsyncAPI\xa0is an open source      | Creating distributed |\n| ynchronous | initiative to create an         | systems where a set  |\n| APIs       | event-driven and\xa0asynchronous   | of API resources are |\n|            | API\xa0standardization and         | well defined.        |\n|            | development tooling.            | Typically used for   |\n|            | The\xa0AsyncAPI\xa0specification,     | asynchronous         |\n|            | inspired by the OpenAPI         | interactions and     |\n|            | specification, describes and    | event driven         |\n|            | documents event-driven\xa0APIs\xa0in  | architectures. Also, |\n|            | a machine-readable format.      | useful when          |\n|            |                                 | developing APIs that |\n|            |                                 | front workflows or   |\n|            |                                 | long running         |\n|            |                                 | orchestrations.      |\n+------------+---------------------------------+----------------------+\n| gRPC       | gRPC\xa0is a modern open source    | Creating distributed |\n|            | high performance Remote         | systems that require |\n|            | Procedure Call (RPC) framework  | highly performant    |\n|            | that can run in any             | and scalable API\\\'s. |\n|            | environment.                    | gRPC makes\xa0use\xa0of    |\n|            |                                 | binary data rather   |\n|            | In gRPC, a client application   | than just text which |\n|            | can directly call a method on a | makes the            |\n|            | server application on a         | communication more   |\n|            | different machine as if it were | compact and more     |\n|            | a local object, making it       | efficient.\xa0          |\n|            | easier for you to create        |                      |\n|            | distributed applications and    |                      |\n|            | services. This is enabled by a  |                      |\n|            | formal Interface Definition     |                      |\n|            | Language (IDL). gRPC utilizes   |                      |\n|            | Protocol Buffers by default,    |                      |\n|            | you can make it work with other |                      |\n|            | data formats, such as JSON.     |                      |\n+------------+---------------------------------+----------------------+'),(0,i.kt)("p",null,"[]{#_heading=h.1d96cc0 .anchor}",(0,i.kt)("em",{parentName:"p"},"Table 19: Types of API")),(0,i.kt)("p",null,"Example Technical Use Case Synchronous/Asynchronous API"),(0,i.kt)("p",null,"The illustrative example below demonstrates a combination of a\nsynchronous API and an asynchronous API."),(0,i.kt)("p",null,"[]{#_heading=h.2ce457m .anchor}",(0,i.kt)("em",{parentName:"p"},"Figure 48: Asynchronous Claims API")),(0,i.kt)("p",null,'The example above has 2 associated API specifications. The first is an\nOpenAPI specification that describes the "Create Claim" and "Get Claim"\nRESTful interactions and the second is an AsyncAPI specification that\ndescribes the "Receive Updates" interaction. These example\nspecifications have been provided in the appendix of this document for\nreference -- see ',(0,i.kt)("a",{parentName:"p",href:"#_heading=h.2vor4mt"},"[Synchronous/Asynchronous Example\nSpecifications]{.underline}")),(0,i.kt)("h3",{id:"api-design-principles"},"API Design Principles"),(0,i.kt)("p",null,"This section assumes that API Principles defined in section 4 of Part A\nof this standard have already been read."),(0,i.kt)("h4",{id:"future-focused-design"},"Future-Focused Design\xa0"),(0,i.kt)("p",null,"APIs should not be tightly coupled to legacy applications, exposing\nwhatever capabilities the legacy system offered. Nor should they be\ndesigned to work in the way the legacy system currently works."),(0,i.kt)("p",null,"Instead they should be consumer driven -- so built to expose the\nresources that consumers need, whether those resources are in legacy\nsystems or new. There should not be a drive to expose an entire product\nvia the API, or wait for the perfect backend system to be available.\nJust offer as much as is practically useful, then evolve it to meet\nneeds. Design the API interface to be abstracted from the backend, so\nthat backend systems can be changed or replaced over time without\nneeding to change the interface."),(0,i.kt)("p",null,"The aim is to be future-focused (whilst still pragmatic) and develop\nAPIs to meet future needs. A good example of being future focussed is\nbuilding APIs to support HATEOAS\xa0(Hypermedia as the Engine of\nApplication State). This is where an API, in response to a consuming\napplication\\'s request, is programmed to return hyperlinks (URLs) which\nindicate the options for subsequent actions or information. See\n",(0,i.kt)("a",{parentName:"p",href:"#hateoas"},"[section 2.7.7]{.underline}")," for more details on HATEOAS."),(0,i.kt)("h4",{id:"layering"},"Layering"),(0,i.kt)("p",null,"When designing and developing an API it is important to consider that an\nAPI is made up of distinct functional layers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Security")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Caching")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Representation"))),(0,i.kt)("h5",{id:"security"},"Security"),(0,i.kt)("p",null,"Every API will have a security component. It is important to recognise\nthat this is not only authentication and authorisation for access to an\nAPI, it also includes threat protection (DDoS, SQL Injection, Cross site\nscripting etc.) as well as availability and quality of service (QoS).\nWhen designing and developing APIs it is often cost effective to create\na common framework that handles security for all APIs. See the\nassociated document, Part B, API Security, for more details."),(0,i.kt)("h5",{id:"caching"},"Caching"),(0,i.kt)("p",null,"Caching can dramatically improve the performance of an API. When\ndesigning APIs consider what, when and where to cache. Understanding how\ndata is changed and how often it is changed is an important\nconsideration, as well as which layer it is most appropriate to cache\nat. A common caching strategy should be developed for APIs that would\nbenefit from it. See ",(0,i.kt)("a",{parentName:"p",href:"#caching"},"[section 2.12]{.underline}")," for more\ndetails."),(0,i.kt)("h5",{id:"representation"},"Representation"),(0,i.kt)("p",null,"When designing and developing an API it is important to consider the\nrepresentation of that API. This commonly includes an interface\nspecification that fully describes the API. To ensure the success of an\nAPI it should be easy to consume driving a well-considered\nrepresentation layer."),(0,i.kt)("p",null,"[]{#_heading=h.2jxsxqh .anchor}",(0,i.kt)("em",{parentName:"p"},"Figure 49: API Layering")),(0,i.kt)("h4",{id:"standards-based"},"Standards-Based"),(0,i.kt)("p",null,"Web standards have rapidly become powerful agreements, which span not\njust local regions but are internationally accepted and enable\ncommonality and consistency.\xa0Using standard\xa0HTTP\xa0and\xa0URLs, the core\ntechnologies of the web, along with standards such as\xa0JSON\xa0and\xa0OAuth\nensures that agencies are not creating bespoke or proprietary\ntechnologies."),(0,i.kt)("p",null,"Hence the principle is to build to the latest versions of existing open\nand accepted standards e.g.\xa0"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"HTTP")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"OpenAPI")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"AsyncAPI")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"REST")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"JSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"OAuth")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"OIDC"))),(0,i.kt)("p",null,"Refer to the ",(0,i.kt)("a",{parentName:"p",href:"#_heading=h.3hej1je"},"[appendix]{.underline}")," for detailed\ninformation about relevant standards."),(0,i.kt)("h3",{id:"designing-an-api"},"Designing an API"),(0,i.kt)("p",null,"When designing an API, it is important to perform business process\nanalysis to ensure that API development is business-driven rather than\ntechnology-driven. Technology driven projects rarely meet customers'\nneeds in the long run, so it important to gain background in who could\nbe using the API, for what. As mentioned previously, co-design is\nfundamental to driving the right API development. To help identify\npotential partners to involve in the co-design, consider:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"processes which currently depend on information the API could expose")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"processes which require a capability an API could expose"))),(0,i.kt)("p",null,"Some actors will be human (e.g. application developers) whilst some\nactors will be the systems which will interact with, or depend on, the\nAPI. There may be different types of actors, some public sector, some\ncommercial entities, some public."),(0,i.kt)("p",null,"When representatives for the potential actors are identified, start\nco-designing with these representatives. First and foremost, consider\nthe requirements for the API. Application developers often couch their\nrequirements in terms of how the API should work, rather than what the\nAPI needs to do. Don't get bogged down in the variety of proposed\nsolutions from each developer: focus on extracting their true\nrequirements by performing functional analysis (e.g. use cases) and data\nflow analysis. Then identify resources and work out the granularity\nneeded (see sections ",(0,i.kt)("a",{parentName:"p",href:"#designing-an-api"},"[2.2.4 Designing an\nAPI]{.underline}")," & ",(0,i.kt)("a",{parentName:"p",href:"#granularity"},"[2.2.7\nGranularity]{.underline}"),")."),(0,i.kt)("p",null,"It is especially important that security and information privacy impacts\nare identified up front and addressed early on in the design process.\nAssess the information being passed and the types of access different\ncustomers and/or consuming applications should have to the API. This\nwill help drive development of security policies alongside the design of\nthe API."),(0,i.kt)("p",null,"One common pitfall in API design is to map all existing data tables onto\nresources and develop the associated CRUD capabilities into an API.\nUsually this results in a poor API design and tightly couples the API\ndesign to the underlying data structure. Another common pitfall is to\ndesign APIs as an extension to, or way into, monolithic legacy systems.\nThis should be avoided as it tightly couples the API to the legacy\nsystem. Both of these pitfalls will create issues for both provider and\nconsumers in the long term."),(0,i.kt)("p",null,"At this point in the design process, agility is probably more important\nthan completeness. Share early design thoughts and interface\nspecifications with the developer community and quickly make changes in\nresponse to their feedback. Work through some sequence diagrams with\nthem to help pin down API interactions and inform API design thinking."),(0,i.kt)("p",null,"The correct API design will likely not please every developer, so don't\ntry to be all things to all developers. A rule of thumb is that you are\nprobably on the right track if most developers are a ",(0,i.kt)("em",{parentName:"p"},"little")," unhappy,\nbut all are able to achieve their aims with the proposed design."),(0,i.kt)("p",null,"It is important not to try to bypass evolution steps and try to build\nfor all potential use cases right from the offset. For a more measured\nprogression towards API delivery, start simple and focus on a single\nchannel or interaction initially. By building onto these simple building\nblocks, API evolution over time naturally progress towards omnichannel\napplications.\xa0"),(0,i.kt)("h3",{id:"design-considerations"},"Design Considerations"),(0,i.kt)("p",null,"The following considerations emerge when looking to develop APIs in the\npublic sector:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Understand your data, understand your consumers. Before starting\nwork on APIs, gain a good understanding of what data you hold, the\ncomplexity of that data, its relationships to other data, the\ndownstream dependents on that data and potential consumers of the\ndata. It is also a good idea to understand your consumers\\' drivers\nand downstream usage or customers.\xa0")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Design for REST. If the interaction appears RESTful then develop a\nREST API, e.g. one-to-many. In some cases however, a gRPC or GraphQL\nAPI may be appropriate and are supported by this document. REST APIs\nare widely understood, easier to govern and suitable for most\ninteroperability use cases. It is also important to note here that\nif there is an appropriate supported standard such as Fast Health\nInteroperability Resource (FHIR) then the resources defined in that\nstandard should be used rather than a set of agency defined\nresources.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The information supplied via an API may still be dependent on\novernight batch processes for update. It is worth making the\ninformation's timeliness and update period clear to potential\nconsumers of the API.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"APIs should not be used to handle large batch transfers because of\nthe atomic nature of the usage i.e. if one single data write fails\nthen the whole batch fails. APIs work better for multiple individual\nupdate transactions."))),(0,i.kt)("h3",{id:"design-driven-development"},"Design Driven Development"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"[Required]","{.smallcaps}")),(0,i.kt)("p",null,"When building APIs, a Design Driven Approach must be taken."),(0,i.kt)("p",null,"This includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Interface specification first")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Iterative approach")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Continuous integration/testing"))),(0,i.kt)("h4",{id:"interface-specification-first"},"Interface Specification First"),(0,i.kt)("p",null,"The best way to design an API is in collaboration with potential\nconsumers of that API. Creating the interface specification first makes\nit easier for application developers to see what the API is going to\noffer and how it could be used. Their early feedback will ensure that\nthe API design is heading on the right track and will be usable and\nappropriate to their needs. Using a simple modelling language to define\nthe interface specification makes it easy to view and edit API\ndefinitions. See ",(0,i.kt)("a",{parentName:"p",href:"#interface-specification"},"[section 2.2.8]{.underline}"),"\nfor more information about defining interface specifications."),(0,i.kt)("h4",{id:"iterative-approach"},"Iterative Approach"),(0,i.kt)("p",null,"It has been acknowledged that big bang releases rarely deliver business\nor customer benefit. An iterative approach, with ongoing releases\noffering gradual improvement or evolving capability, gives a finer tuned\ndelivery, better sense of momentum, illustrates progress and enables\nthird parties to coordinate efforts with API developments. ICT.govt.nz\nAccelerate\n(",(0,i.kt)("a",{parentName:"p",href:"https://www.ict.govt.nz/guidance-and-resources/accelerate/"},"[https://www.ict.govt.nz/guidance-and-resources/accelerate/]{.underline}"),")\noffers a framework which supports this kind of development and has\nguidance on how to deliver transformational projects."),(0,i.kt)("p",null,"An iterative approach incorporates continuous improvement, which\nrecognises the need to support continuing evolvement of the API beyond\nthe first delivery. The API is a product whose capabilities should\nundergo continuing improvements based on consumer feedback, performance\nanalytics and emerging needs. This aligns to Phase 6 in the Accelerate\nframework."),(0,i.kt)("h4",{id:"automation-first"},"Automation First"),(0,i.kt)("p",null,"Automation provides a quick turnaround for informing API developers\nabout breaking changes being submitted by developers who are all working\non the same code base or product (e.g. API). The idea is that all\ndevelopers submit code changes as often as possible (e.g. into a version\ncontrol system), allowing code to go through an automated, integrated\nbuild process which ensures that nothing has broken the build. This\nbuild process could happen many times a day. Any errors are quickly\nidentified and alerted to the team who can rectify them in a timely\nfashion."),(0,i.kt)("p",null,"Tests can be written against the interface specification quite early on\nin the development process by developing just enough API code to enable\nthe test to be run (stubs). The tests can then be incorporated into the\nautomated build process, giving early warning of regression test\nfailures. API code should not be able to progress through SDLC\nenvironments until successful test execution."),(0,i.kt)("h3",{id:"granularity"},"Granularity"),(0,i.kt)("p",null,"There is a question as to how fine-grained an API resource should\nbe.\xa0APIs should be designed at the lowest practical level of granularity\nbecause this makes each service simpler and allows them to be combined\nin ways that suit the application developer. The key principle is to\ndesign services that can be re-used and combined in different ways, and\nnot tie the application developer to a specific way of working or\nsequence of API consumption just because that is how it is configured or\nbuilt in the back end."),(0,i.kt)("p",null,"If an API offers very fine-grained resources, then consuming\napplications end up having to make many more calls to the API in order\nto collect all the information they need, resulting in chattier\ncommunications. On the other hand, if the API is based on very coarse\ngrained resources (returning everything about the resource) the response\npayloads could end up being enormous, may not support all API\napplication developers' needs, and the API could become cumbersome to\nuse and maintain."),(0,i.kt)("p",null,"There may also be a need for varying granularity within one API,\ndepending on the purpose and use of that API. For example, if a blogging\nAPI was being created, it may make sense to offer a coarse grained\nresource for posting a new blog entry as a bundle of content including\npictures, sound, keywords as well as the textual blog entry. But when\noffering the ability to like or comment on a blog entry it would make\nsense,\xa0for clarity and ease of use,\xa0to offer these as separate\nsub-resources, one for indicating a \\'like\\' and one for submitting a\ncomment.\xa0\xa0"),(0,i.kt)("p",null,"It is important to aim for a granularity which will prevent business\nlogic from leaking into the API e.g. requiring API calls to be made in a\ncertain sequence to meet with internal business processes. With the\nblogging example, consider the impact of a fine-grained API being\noffered for posting blog entries, with separate calls for adding images,\nsounds and metadata. If metadata is mandatory, then the API application\ndeveloper needs to ensure that every blog post call is followed by a\nmetadata call. This puts the onus on the application developer to get\nthe sequence of calls correct and could lead to inconsistent data if\nthey do not adhere to the rules. It also leads to close coupling between\nthe consuming application and the API, and if the business logic changes\nin the future there is a downstream impact on all application\ndevelopers, requiring them to modify their applications."),(0,i.kt)("p",null,"General guidelines are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Don\\'t aim for the finest granularity - an API should be built\naround each discrete and updateable resource")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There does not need to be a one-to-one mapping between a manual\nservice and a corresponding API; APIs should support the process but\nnot try to encapsulate the process")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A rough guide is to have one API operation for each entity lifecycle\nstate transition")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Resources can be identified by reviewing a business process and\nidentifying the key entities which underpin the process. Any\nentities which the organisation manages or maintains throughout its\nfull lifecycle will be potential API resources.\xa0There is typically\none API operation for each entity lifecycle state transition.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There should be only one API function for one business outcome (e.g.\nchange an address)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Consider using query parameters in\xa0URLs\xa0for different granularity of\nresources. For example,\xa0/passengers.json\xa0could return a list of\nnames, whilst /passengers.json?detail=full\xa0could return detailed\ninformation about each passenger in a list."))),(0,i.kt)("h3",{id:"interface-specification"},"Interface Specification"),(0,i.kt)("p",null,"An API represents a contract between the provider and the consumer for\naccess to provider resources. Because API consumption is a programmatic\nexercise, it is important to have a clear definition of what the API\noffers and how those API resources are to be accessed. This definition\nis the interface specification.\xa0"),(0,i.kt)("p",null,"The interface specification should be designed in advance of developing\nthe API, as the act of working out the specification often helps think\nthrough all the issues that could impact the design of the underlying\nresource-handling code. It also helps consuming application developers\nto review the capabilities being offered to see if the capabilities meet\ntheir needs before they start developing to the specification. When\noutsourcing API development, the interface specification can be written\nin abstract as a means of defining the API the vendor should build. The\nspecification can be handled as a separate entity, is version\ncontrollable, and it should be possible to use it as the main API\ndocumentation or reference. \xa0"),(0,i.kt)("p",null,"There are several API modelling languages available for defining the\ninterface specification. Some are proprietary (e.g. RAML, API Blueprint)\nwhilst others are machine-readable but not human readable (e.g. WADL).\nThe most commonly used API modelling language today is an open standard\nknown as the OpenAPI Specification (formerly Swagger) maintained by the\nOpen API Initiative. This initiative is supported by many of the main\ncommercial entities in IT (Google, IBM, Microsoft, Atlassian, Paypal\netc.). It offers\xa0a standard, programming language-agnostic (JSON/YAML)\ninterface to REST APIs which allows both humans and computers to\ndiscover and understand the capabilities of the service. For an example\nof a Swagger interface specification see Appendix C - Example Interface\nSpecification."),(0,i.kt)("p",null,"It is important to use a modelling language to define the API interface\nspecification as essentially it is text or code and can be maintained\nusing source code management systems."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"[Recommended]","{.smallcaps}")),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"https://openapis.org/"},"[OpenAPI/Swagger]{.underline}")," as the\ninterface specification language for all APIs being developed."),(0,i.kt)("h3",{id:"orchestration"},"Orchestration"),(0,i.kt)("p",null,"As a general rule using APIs as an orchestration tool is not\nrecommended. This is due to the complexity that this can introduce to an\nAPI architecture. That said, however, simple orchestration may in some\ncases be appropriate. An example of this may be a mashup API that\ncreates a new logical API resource by combining related data held in two\nor more back end systems."),(0,i.kt)("p",null,"A mashup is not appropriate when you create an API that merges two\ndistinct API products together. If a consumer requires this\nfunctionality the mashup should be performed by the consuming\napplication."),(0,i.kt)("p",null,"Other examples of simple orchestration could include mediation such as\nmessage transformation (JSON to XML or canonical message model\ntransformation)."),(0,i.kt)("h3",{id:"software-development-kits-sdk"},"Software Development Kits (SDK)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"[Recommended]","{.smallcaps}")),(0,i.kt)("p",null,"It is recommended that API Providers offer an SDK to developers of\nconsuming applications."),(0,i.kt)("p",null,"An SDK can be considered the implementation toolset for use of an\nagency's APIs. By providing developers with an SDK they can build\napplications faster without having to understand all of the API's\ncomplexities. An SDK should provide sample code that explains the\nfunctionality of your API to potential application developers."),(0,i.kt)("p",null,"An example of a public service API SDK can be found at the [",(0,i.kt)("a",{parentName:"p",href:"http://usdepartmentoflabor.github.io/Ruby-Sample-App/"},"US\nDepartment of Labour GitHub\nrepository"),"]{.underline}\nPublication/Catalogue"),(0,i.kt)("p",null,"Once an API is in sufficient state to be offered to API consumers, the\nAPI definition should be published to an API catalogue. The primary API\ndiscoverer is the developer, so an external API must be well documented,\nand provide accurate and up-to-date guidance via the catalogue."),(0,i.kt)("p",null,"Government are considering options for a central point of discovery for\nexternally accessible public sector APIs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"[Recommended]","{.smallcaps}")),(0,i.kt)("p",null,"Publishing to a catalogue is recommended for internal APIs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"[Required]","{.smallcaps}")),(0,i.kt)("p",null,"Publishing to a catalogue is required for external APIs."))}u.isMDXComponent=!0}}]);